# -*- coding: utf-8 -*-
"""FinalProyecto2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/10o51HISARDp58lpqTUcOe_VRQ49Db95h
"""

pip install pgmpy

import pandas as pd
import networkx as nx
import matplotlib

df = pd.read_excel("/content/drive/MyDrive/Colab Notebooks/dataP22.xlsx")

print(df.head())
print(df.describe())
print(df.columns)

df= df.dropna()

from pgmpy.estimators import PC
est = PC(data=df)

estimated_model = est.estimate(variant="stable", max_cond_vars=4)
print(estimated_model)
print(estimated_model.nodes())
print(estimated_model.edges())

from pgmpy.models import BayesianNetwork
from pgmpy.estimators import MaximumLikelihoodEstimator

estimated_model = BayesianNetwork(estimated_model)
estimated_model.fit(data=df, estimator = MaximumLikelihoodEstimator)
for i in estimated_model.nodes():
    print(estimated_model.get_cpds(i))

nx.draw_shell(estimated_model, with_labels=True)



from pgmpy.estimators import HillClimbSearch
from pgmpy.estimators import K2Score
from pgmpy.models import BayesianNetwork

scoring_method = K2Score(data=df)
esth = HillClimbSearch(data=df)
estimated_modelh = esth.estimate(
    scoring_method=scoring_method, max_indegree=4, max_iter=int(1e4)
)
print(estimated_modelh)
print(estimated_modelh.nodes())
print(estimated_modelh.edges())

print(scoring_method.score(estimated_modelh))

estimated_modelh = BayesianNetwork(estimated_modelh)

nx.draw_shell(estimated_modelh, with_labels=True)

from sklearn.model_selection import train_test_split
from pgmpy.models import BayesianNetwork
train,test = train_test_split(df, test_size=0.2,random_state= 42)

from pgmpy.inference import VariableElimination
estimated_modelh.fit(data = train, estimator = MaximumLikelihoodEstimator)
inferh = VariableElimination(estimated_modelh)

df.isna().sum()

train

from pgmpy.estimators import BicScore
scoring_method = BicScore(data=df)
esth = HillClimbSearch(data=df)
estimated_modelB = esth.estimate(
    scoring_method=scoring_method, max_indegree=4, max_iter=int(1e4)
)
print(estimated_modelB)
print(estimated_modelB.nodes())
print(estimated_modelB.edges())

print(scoring_method.score(estimated_modelB))

nx.draw_shell(estimated_modelB, with_labels=True)



from pgmpy.inference import VariableElimination
from sklearn.metrics import accuracy_score, confusion_matrix

inference = VariableElimination(estimated_model)

# Obtener las predicciones de Target
predicted_target = []
for idx, row in df.iterrows():
    evidence = {
        "Daytime": row["Daytime"],
        "Tuition": row["Tuition"],
        "ApplicationOrder": row["ApplicationOrder"],
        "Displaced": row["Displaced"],
        "Curricular units 1st sem (approved)": row["Curricular units 1st sem (approved)"],
        "Curricular units 2nd sem (approved)": row["Curricular units 2nd sem (approved)"]
    }
    target_probabilities = inference.query(variables=["Target"], evidence=evidence)
    predicted_target.append(target_probabilities.values.argmax())

# Calcular la precisión
actual_target = df["Target"].tolist()
accuracy = accuracy_score(actual_target, predicted_target)
print(f"Precisión (Accuracy): {accuracy:.2f}")

inference = VariableElimination(estimated_modelh)

from numpy.matrixlib.defmatrix import mat
matriz = confusion_matrix(df["Target"],predicted_target)

matriz

import pandas as pd
from pgmpy.models import BayesianNetwork
from pgmpy.estimators import ParameterEstimator
from pgmpy.estimators import MaximumLikelihoodEstimator
from pgmpy.inference import VariableElimination

from pgmpy.sampling import BayesianModelSampling
from pgmpy.factors.discrete import TabularCPD


from sklearn.metrics import accuracy_score, confusion_matrix



#-------------------------------------------DASH-----------------------------
import dash
from dash import dcc
from dash import html
import pandas as pd
import plotly.express as px
from dash.dependencies import Input, Output
from pgmpy.models import BayesianNetwork
from pgmpy.inference import VariableElimination
import plotly.graph_objs as go



#Crear la aplicación Dash
app = dash.Dash(__name__, external_stylesheets=['https://codepen.io/chriddyp/pen/bWLwgP.css'])
server = app.server


app.layout = html.Div([
    html.H1("Riesgo de deserción de los estudiantes"),
    html.H2("Llene la infiormacion a continuación para poder hacer una predicción del perfil del estudiante "),

    html.Label("The student is a scholarship holder?"),
    dcc.RadioItems(
        id="scholarship-holder",
        options=[
            {"label": "Yes", "value": "Yes"},
            {"label": "No", "value": "No"}
        ],
        value="Yes"
    ),


    html.Label("How many applications has the student made so far?"),
    dcc.Input(
        id="application-order",
        type="number",
        value=0
    ),


    html.Label("The student has all his tuition payments up to date?"),
    dcc.RadioItems(
        id="tuition-up-to-date",
        options=[
            {"label": "Yes", "value": "Yes"},
            {"label": "No", "value": "No"}
        ],
        value="Yes"
    ),


    html.Label("Is the student displaced?"),
    dcc.RadioItems(
        id="displaced",
        options=[
            {"label": "Yes", "value": "Yes"},
            {"label": "No", "value": "No"}
        ],
        value="Yes"
    ),


    html.Label("What is the father's qualification?"),
    dcc.Input(
        id="father-qualification",
        type="text",
        value=""
    ),


    html.Label("Of the number of exams taken, how many exams did the student passed in semester 1? (Max 26)"),
    dcc.Input(
        id="exams-passed-sem1",
        type="number",
        value=0
    ),


    html.Label("Of the number of exams taken, how many exams did the student passed in semester 2? (Max 26)"),
    dcc.Input(
        id="exams-passed-sem2",
        type="number",
        value=0
    ),


    html.Label("Which is the daytime of the student attendance to the school?"),
    dcc.Dropdown(
        id="attendance-daytime",
        options=[
            {'label': 'Daytime', 'value': 'Daytime'},
            {'label': 'Evening', 'value': 'Evening'}
        ],
        value=""
    ),


    html.H2("Answers"),
    html.Div(id="answers"),
    dcc.Graph(id='prediction-graph'),
])




@app.callback(
    Output("answers", "children"),
    Output('prediction-graph', 'figure'),
    Input("scholarship-holder", "value"),
    Input("application-order", "value"),
    Input("tuition-up-to-date", "value"),
    Input("displaced", "value"),
    Input("father-qualification", "value"),
    Input("exams-passed-sem1", "value"),
    Input("exams-passed-sem2", "value"),
    Input("attendance-daytime", "value")
)
def calculate_answers(scholarship_holder, application_order, tuition_up_to_date, displaced, father_qualification,
                      exams_passed_sem1, exams_passed_sem2, attendance_daytime):

    inference = VariableElimination(estimated_model)

    evidence = {
        "ScholarshipHolder": scholarship_holder,
        "ApplicationOrder": application_order,
        "Tuition": tuition_up_to_date,
        "Displaced": displaced,
        "FatherQualification": father_qualification,
        "Curricular units 1st sem (approved)": exams_passed_sem1,
        "Curricular units 2nd sem (approved)": exams_passed_sem2,
        "Daytime": attendance_daytime
    }

    
    target_probabilities = inference.query(variables=["Target"], evidence=evidence)    

    target_values = ["dropout", "graduate", "enrolled"]
    predicted_target = target_values[target_probabilities.values.argmax()]

    data = [
        go.Bar(x=target_values, y=target_probabilities.values, text=target_probabilities.values, textposition='auto')
    ]
    layout = go.Layout(title="Probabilities for Target Categories")
    fig = go.Figure(data=data, layout=layout)


    result_text = f"Predicted Target: {predicted_target}"

    return result_text, fig

# Ejecutar la aplicación Dash
if __name__ == "__main__":
    app.run_server(debug=True)
